## npm、yarn

同一个依赖，更高版本的包会安装到顶层目录，即 node_modules 目录；否则会分散在某些依赖的 node_modules 目录，如：node_modules/expect-jsx/node_modules/react 目录。

如果依赖升级，造成版本不兼容，需要多版本共存，那么仍然是将高版本安装到顶层，低版本分散到各级目录。

lockfile 的存在，保证了项目依赖结构的确定性，保障了项目在多环境运行的稳定性

详细流程：[https://mp.weixin.qq.com/s/Zp9p-BAosfvCT0iDMz1aEw](https://mp.weixin.qq.com/s/Zp9p-BAosfvCT0iDMz1aEw)

## requestAnimationFrame 执行时机

它告诉浏览器 -- 希望执行一个动画（仅一次），并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。

该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()

### 使用css3动画代替js的动画有什么好处？

不占用JS主线程

可以利用硬件加速

浏览器可对动画做优化（元素不可见时不动画，减少对FPS的影响）

## 使用 worker

```javascript
var worker = new Worker('a.js');
worker.postMessage('Hello World');
worker.onmessage = function (e) {
    console.log(e.data);
}
```

另外可以关注下 SharedWorker、sharedworker-loader

## 实现三栏布局（简单写下）

1、flex布局：父盒子display:flex，左右盒子宽度写死，中间设置flex:1

2、左右两边的盒子分别左右浮动，中间自适应（设置margin或calc）

## css 实现图片翻转

```css
.demo {
    /* 方案一 */
    transform: scale(-1, 1);

    /* 方案二 */
    transform: rotateY(180deg);
}
```

## 移动端 1px 问题

1px 的边框，再高清屏下会显得很粗

DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。

window.devicePixelRatio=物理像素 /CSS像素

解决方案：

+ 0.5px

+ 使用边框图片

```css
.demo {
    border: 1px solid transparent;
    border-image: url('aa.jpg') 2 repeat;
}
```

+ 使用 box-shadow

```css
/*    //上边线  //右边线    //下边线    //左边线 */
.demo {
    box-shadow: 0 -1px 1px -1px #e5e5e5,
    1px 0 1px -1px #e5e5e5,
    0 1px 1px -1px #e5e5e5,
    -1px 0 1px -1px #e5e5e5;
}
```

+ 使用伪元素

```scss
//1 条 border 时
//将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小0.5倍。
.setOnePx {
  position: relative;

  &::after {
    position: absolute;
    content: '';
    background-color: #e5e5e5;
    display: block;
    width: 100%;
    height: 1px; /*no*/
    transform: scale(1, 0.5);
    top: 0;
    left: 0;
  }
}
```

+ 设置 viewport 的 scale 值，利用viewport+rem+js 实现

## Hybrid 通信

+ API注入，原理其实就是 Native 获取 JavaScript环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式

+ WebView 中的 prompt/console/alert 拦截，通常使用 prompt，因为这个方法在前端中使用频率低，比较不会出现冲突

+ WebView URL Scheme 跳转拦截

## npm ci

npm ci(以持续集成命名)直接从package-lock.json安装依赖关系，并且仅使用package.json来验证没有不匹配的版本。

如果缺少任何依赖项或版本不兼容，则将引发错误。

而 npm install读取package.json以创建依赖关系列表，并使用package-lock.json告知要安装这些依赖关系的版本。

如果依赖项不在package-lock.json中，它将由npm install添加。

## 实现左边竖条

```css
.target {
    background: black;
    width: 50%;
    height: 3px;
    transform-origin: 0;
    transform: rotate(90deg);
}
```

```css
.text-mark {
    border-left: solid #298dff 3px;
    padding-left: 4px;
}
```

## ::marker伪元素

::marker伪元素与:before和:afte功能类似，都有一个content属性，用于生成一个项目符号或数字。

::marker的一些限制：

1. 能够响应::marder的元素只能是list item，如ul和ol中的li是list item；
2. 如果不是list item元素，可以添加属性display: list-item，然后使用::marker；
3. 只能对部分属性进行设置；如所以字体属性、颜色值、content内容、文档书写方向相关；
4. ::marker是可以动态变化的；例如li::marker { content: '>'};li:hover::marker{ color: red};鼠标放到'>'上就会变为红色。
