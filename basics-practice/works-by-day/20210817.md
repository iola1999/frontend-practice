## 变量提升和严格模式

JavaScript 只有声明的变量会提升，初始化的不会。

严格模式的写法就是在代码编写之前加上"use strict"，严格模式要求你不能使用未声明的变量，否则会报错。

## 二叉树遍历

### 遍历方式

                A
              /   \
            B      C
          /  \     / \
         D    E   F   G
        / \   /
       H  I  J

1. 二叉树的前序遍历：先访问一个节点，再访问该节点的左右子树。

前序遍历输出为：ABDHIEJCFG

+ 迭代

```javascript
function preorderTraversal(root) {
    if (!root) {
        return []
    }
    const stack = [root]
    const res = []
    while (stack) {
        const cur = stack.pop()
        res.push(cur.val)
        if (cur.right) {
            stack.push(cur.right)
        }
        if (cur.left) {
            stack.push(cur.left)
        }
    }
    return res
}
```

+ 递归

```javascript
function preorderTraversal(root) {
    if (!root) {
        return []
    }
    return [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)]
}
```

2. 二叉树的中序遍历：先访问一个节点的左子树，然后访问该节点，最后访问右子树。

中序遍历输出为：HDIBJEAFCG

TODO：

```javascript

```

3. 二叉树的后序遍历：先访问一个节点的左右子树，再访问该节点。

后序遍历输出为：HIDJEBFGCA

4. 二叉树的层次遍历

层次遍历就是按照树的层次自上而下的遍历二叉树。针对图4-1所示二叉树的层次遍历结果为：ABCDEFGHIJ

### 确定二叉树的高度

1. 递归求解，属于DFS深度优先搜索算法

```javascript
function getHeight(root) {
    if (root == null) {
        return 0;
    }
    const i = getHeight(root.left);//左树高
    const j = getHeight(root.right);//右树高
    return (i < j) ? j + 1 : i + 1;
}
```

2. 层次遍历

BFS广度优先搜索算法。

其实还有非递归实现：层次遍历，使用队列。每往下遍历一层，树的高度增加1；当遍历结束，自然可以得到树的高度；

```cpp
int TreeDepth(TreeNode* pRoot)
{
    if(pRoot == NULL){
        return 0;
    }
    queue<TreeNode*> que;
    int depth = 0;
    que.push(pRoot);
    while(!que.empty()){
        int size = que.size();
        depth++;
        for(int i = 0; i < size; i++){
            TreeNode* node = que.front();
            que.pop();
            if(node->left){
                que.push(node->left);
            }
            if(node->right){
                que.push(node->right);
            }
        }
    }
    return depth;
}
```

## 堆叠上下文

[https://www.w3cplus.com/css/what-no-one-told-you-about-z-index.html](https://www.w3cplus.com/css/what-no-one-told-you-about-z-index.html)

同一个父元素下面的元素会受父元素的堆叠顺序影响，所以堆叠上下文是我们理解z-index和堆叠顺序的关键。（下面为了简化，我们称堆叠上下文为层。）

每一个层都有唯一的根节点。当一个元素创建一个层，那么它的所有子元素都会受到父元素的堆叠顺序影响。意味着如果一个元素位于一个最低位置的层，那你z-index设置得再大，它也不会出现在其它层元素的上面。

现在我们来说说什么情况下会产生新的层：

+ 当一个元素位于HTML文档的最外层（<html>元素）
+ 当一个元素被定位了并且拥有一个z-index值（不为auto）
+ 当一个元素被设置了opacity，transforms, filters, css-regions, paged media等属性。

## 同一层里面的堆叠顺序

下面是同一层里面的堆叠顺序（从后到前）：

+ 层的根元素
+ 被定位了得元素并且z-index值为负，相同z-index的情况下，按照HTML元素的书写顺序排列，下面相同。
+ 没有被定位的元素
+ 被定位的元素，并且z-index值为auto
+ 被定位了的元素并且z-index值为正。



