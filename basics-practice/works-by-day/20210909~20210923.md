## Vue 的细节

[https://mp.weixin.qq.com/s/gdJWm5Jj1_YhpMUjlfcBVg](https://mp.weixin.qq.com/s/gdJWm5Jj1_YhpMUjlfcBVg)

Vue.js 的响应式系统依赖三个重要的概念，Observer、Dep、Watcher

- 发布者-Observer

  Observe 扮演的角色是发布者，他的主要作用是在组件 vm 初始化的时，调用 defineReactive 函数，使用 Object.defineProperty 方法对对象的每一个子属性进行数据劫持/监听。

  即为每个属性添加 getter 和 setter，将对应的属性值变成响应式。

- 调度中心/订阅器-Dep

  Dep 扮演的角色是调度中心/订阅器，在调用 defineReactive 将属性值变成响应式的过程中，也为每个属性值实例化了一个 Dep，主要作用是对观察者（Watcher）进行管理，收集观察者和通知观察者目标更新。

  即当属性值数据发生改变时，会遍历观察者列表（dep.subs），通知所有的 watcher，让订阅者执行自己的 update 逻辑。

- 观察者-Watcher

  Watcher 扮演的角色是订阅者/观察者，他的主要作用是为观察属性提供回调函数以及收集依赖，当被观察的值发生变化时，会接收到来自调度中心 Dep 的通知，从而触发回调函数。

  而 Watcher 又分为三类，normal-watcher、 computed-watcher、 render-watcher。

  这三种 Watcher 也有固定的执行顺序，分别是：computed-render -> normal-watcher -> render-watcher。这样就能尽可能的保证，在更新组件视图的时候，computed
  属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据。

### 如果不同 route 使用同一个组件

切换路由时并不会触发 beforeDestory 或者重新触发 created 等

## Git 协作

### Git 分支命名

- master：主分支，负责记录上线版本的迭代，该分支代码与线上代码是完全一致的。

- develop：开发分支，该分支记录相对稳定的版本，所有的 feature 分支和 bugfix 分支都从该分支创建。其它分支为短期分支，其完成功能开发之后需要删除

- feature/\*：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 develop 分支，之后删除该分支。

- bugfix/\*：bug 修复分支，用于修复不紧急的 bug，普通 bug 均需要创建 bugfix 分支开发，开发完成自测没问题后合并到 develop 分支后，删除该分支。

- release/\*：发布分支，用于代码上线准备，该分支从 develop 分支创建，创建之后由测试同学发布到测试环境进行测试; 测试过程中发现 bug 需要开发人员在该 release 分支上进行 bug 修复，所有 bug
  修复完后，在上线之前，需要合并该 release 分支到 master 分支和 develop 分支。

- hotfix/\*：紧急 bug 修复分支，该分支只有在紧急情况下使用，从 master 分支创建，用于紧急修复线上 bug，修复完成后，需要合并该分支到 master 分支以便上线，同时需要再合并到 develop 分支。

## 以下题目来源

[https://juejin.cn/post/6866082181455249422](https://juejin.cn/post/6866082181455249422)

这篇文章挺多实际问题，值得看。

## ES6 Proxy 可以拦截的操作

get、set、has、deleteProperty、ownKeys......、apply、construct（拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)）

## 浏览器获取粘贴事件、文件拖入事件

### 粘贴

粘贴事件提供了一个 clipboardData 的属性，如果该属性有 items 属性，那么就可以查看 items 中是否有图片类型的数据了。Chrome 有该属性，Safari 没有。

```javascript
pasteEle.addEventListener("paste", function (e) {
  if (!(e.clipboardData && e.clipboardData.items)) {
    return;
  }
});
```

items 的 DataTransferItem 有两个属性 kind（一般为 string 或者 file）和 type（MIME-Type），有方法：getAsFile（kind 是文件时）、getAsString

type 常见：text/plain、text/html、Files

getAsString 方法是传入一个回调函数接收文字内容

### 文件拖入

dragenter(文件拖拽进)、dragover(文件拖拽在悬浮)、dragleave(文件拖拽离开)、drop(文件拖拽放下)。

还需要阻止默认行为（例如拖入 pdf 页面就跳走到预览了）

```javascript
dropZone.addEventListener("drop", function (e) {
  e.preventDefault();
  e.stopPropagation();

  var df = e.dataTransfer;
  var dropFiles = []; // 存放拖拽的文件对象

  if (df.items !== undefined) {
    // Chrome有items属性，对Chrome的单独处理
    for (var i = 0; i < df.items.length; i++) {
      var item = df.items[i];
      // 用webkitGetAsEntry禁止上传目录
      if (item.kind === "file" && item.webkitGetAsEntry().isFile) {
        var file = item.getAsFile();
        dropFiles.push(file);
      }
    }
  }
}
```

## js 怎样实现压缩图片

[https://segmentfault.com/a/1190000023486410](https://segmentfault.com/a/1190000023486410)

## koa 与 express 对比

- express 内置了许多中间件可供使用，而 koa 没有。

- express 包含路由，视图渲染等特性，而 koa 只有 http 模块。

- express 的中间件模型为线型，而 koa 的中间件模型为 U 型，也可称为洋葱模型构造中间件。

- express 通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。

总结：

Express

- 优点：线性逻辑，通过中间件形式把业务逻辑细分、简化，一个请求进来经过一系列中间件处理后再响应给用户，清晰明了。
- 缺点：基于 callback 组合业务逻辑，业务逻辑复杂时嵌套过多，异常捕获困难。

Koa

- 优点：首先，借助 co 和 generator，很好地解决了异步流程控制和异常捕获问题。其次，Koa 把 Express 中内置的 router、view 等功能都移除了，使得框架本身更轻量。
- 缺点：社区相对较小。

## unicode 与中文转换

```javascript
escape("你好").replace(/\%u/g, "/u"); // "/u4F60/u597D"
eval("'" + "\u4F60\u597D" + "'"); // 你好
unescape("\u4F60\u597D"); // 你好
```

## git hook

经常用到的工具包是 husky (opens new window),通过 husky 源码知道，它替换了项目中.git/hooks 钩子。

项目中常用钩子是 precommit, prepush, commit-msg

## DNS Prefetch

- 自动解析

浏览器使用超链接的 href 属性来查找要预解析的主机名。当遇到 a 标签，浏览器会自动将 href 中的域名解析为 IP 地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在 HTTPS 页面中不会自动解析。

- 手动解析

在页面添加如下标记：`<link rel="dns-prefetch" href="//g.alicdn.com" />`

可以通过 `<meta http-equiv="x-dns-prefetch-control" content="off">` 禁用隐式的预解析

## flex: 1 省略的其他属性

flex 复合属性，是 flex-grow（放大比例）、flex-shrink（缩小比例）和 flex-basis 属性的简写，值以空格分隔

flex-basis 设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在 flex-grow 和 flex-shrink 生效前的尺寸。

## 类数组

具有：指向对象元素的数字索引下标以及 length 属性告诉我们对象的元素个数

不具有：诸如 push 、 forEach 以及 indexOf 等数组对象具有的方法

典型例子：

DOM 方法: document.querySelectorAll

```javascript
// 类数组对象
let arrayLikeObj = {
  length: 2,
  0: "This is Array Like Object",
  1: true,
};
```

```javascript
// 类数组函数
let arrayLikeFunc1 = function () {
};
console.log(arrayLikeFunc1.length); // 0
```

## css 实现文本行数上限

```css
.text-block {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}
```

当标签内是英文字符的时候，会发现样式失效了。英文是不会自动换行的，所以添加如下属性以兼容英文字符。

```css
.text-block {
  word-wrap: break-word;
  word-break: break-all;
}
```

## TCP、UDP 等细节对比

[https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.2](https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.2)

## HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用的区别

- HTTP/1 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
- HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。

## 匿名函数也可以调用自身

arguments.callee()

不过 ES5 严格模式 下是不行的

另外，严格模式：

- 严格模式通过抛出错误来消除了一些原有静默错误。
- 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
- 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。

## 寄生式组合继承

```javascript
//寄生组合式继承的核心方法
function inherit(child, parent) {
  //  继承父类的原型，重写子类的原型为它
  child.prototype = Object.create(parent.prototype);
  // 重写被污染的子类的constructor，最终生成对象时会调用它，其内部 parent.call(this, arg)
  child.prototype.constructor = child;
}
```

简单说明一下：

子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性；

子类可以传递动态参数给父类；

父类的构造函数只执行了一次。

然而，仍然存在一个美中不足的问题：

子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。

所以，我们可以将其优化一下：

```javascript
function inherit(child, parent) {
  // 继承父类的原型
  const parentPrototype = Object.create(parent.prototype);
  // 将父类原型和子类原型合并，并赋值给子类的原型
  child.prototype = Object.assign(parentPrototype, child.prototype);
  // 重写被污染的子类的constructor
  p.constructor = child;
}
```

## 实现 Object.create

```javascript
//实现Object.create方法
function create(proto) {
  function Fn() {
  }

  Fn.prototype = proto;
  Fn.prototype.constructor = Fn;
  return new Fn();
}

let demo = {
  c: "123",
};
let cc = Object.create(demo);
```

## 一些代码实现

### 正则实现 trim

```javascript
String.prototype.trim = function () {
  return this.replace(/^\s+|\s+$/g, "");
};

//或者
function trim(string) {
  return string.replace(/^\s+|\s+$/g, "");
}
```

### 数字千分位分割

```javascript
// 正则
const reg2 = /(?!^)(?=(\d{3})+$)/g;
console.log("123456789".replace(reg2, ','));
```

```javascript
// js
function threeSplit(input) {
  const arr = input.split("").reverse();
  const result = []
  for (let i = 0; i < arr.length; i++) {
    result.push(arr[i])
    if ((i + 1) % 3 === 0 && i !== arr.length - 1) {
      result.push(',')
    }
  }
  console.log(result.reverse().join(""))
}

threeSplit("12345678")
```

### 单例模式

闭包存起来实例

```javascript
let CreateSingleton = (function () {
  let instance;
  return function (name) {
    if (instance) {
      return instance;
    }
    this.name = name;
    return instance = this;
  }
})();
CreateSingleton.prototype.getName = function () {
  console.log(this.name);
}

let Winner = new CreateSingleton('Winner');
let Looser = new CreateSingleton('Looser');

console.log(Winner === Looser); // true
console.log(Winner.getName());  // 'Winner'
console.log(Looser.getName());  // 'Winner'
```

### 一个随机抽奖的函数写法，可以参考下思路

输入为表示对象数组，对象有属性n表示人名，w表示权重。随机返回一个中奖人名，中奖概率和w成正比

```javascript
let peoples = [
  {n: 'p1', w: 1},
  {n: 'p2', w: 100},
  {n: 'p3', w: 100}
];
let rand = function (p) {
  const totalWeight = p.reduce(function (pre, cur, index) {
    cur.startW = pre;
    return cur.endW = pre + cur.w
  }, 0)
  let random = Math.ceil(Math.random() * totalWeight)
  let selectPeople = p.find(people => people.startW < random && people.endW > random)
  return selectPeople.n
};
```

类似地，还有红包随机金额（线段树）

### Promise 实现

真不想写这个。可以注意下链式调用应该怎样实现

```javascript
class MyPromise {
  constructor(fn) {
    this.callbacks = [];
    this.state = "PENDING";
    this.value = null;

    fn(this._resolve.bind(this), this._reject.bind(this));
  }

  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) =>
            this._handle({
              onFulfilled: onFulfilled || null,
              onRejected: onRejected || null,
              resolve,
              reject,
            })
    );
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  _handle(callback) {
    if (this.state === "PENDING") {
      this.callbacks.push(callback);

      return;
    }

    let cb =
            this.state === "FULFILLED" ? callback.onFulfilled : callback.onRejected;
    if (!cb) {
      cb = this.state === "FULFILLED" ? callback.resolve : callback.reject;
      cb(this.value);

      return;
    }

    let ret;

    try {
      ret = cb(this.value);
      cb = this.state === "FULFILLED" ? callback.resolve : callback.reject;
    } catch (error) {
      ret = error;
      cb = callback.reject;
    } finally {
      cb(ret);
    }
  }

  _resolve(value) {
    if (value && (typeof value === "object" || typeof value === "function")) {
      let then = value.then;

      if (typeof then === "function") {
        then.call(value, this._resolve.bind(this), this._reject.bind(this));

        return;
      }
    }

    this.state === "FULFILLED";
    this.value = value;
    this.callbacks.forEach((fn) => this._handle(fn));
  }

  _reject(error) {
    this.state === "REJECTED";
    this.value = error;
    this.callbacks.forEach((fn) => this._handle(fn));
  }
}

const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error("fail")), 3000);
});

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000);
});

p2.then((result) => console.log(result)).catch((error) => console.log(error));
```

### LRU 简单的实现方案

```javascript
class LRU {
  constructor(max) {
    this.max = max
    this.cache = new Map()
  }

  get(key) {
    const {cache} = this
    const value = cache.get(key)
    if (!value) return -1
    cache.delete(key)
    cache.set(key, value)
    return value
  }

  set(key, value) {
    const {cache, max} = this
    if (cache.has(key)) {
      cache.delete(key)
    }
    if (cache.size === max) {
      cache.delete(cache.keys().next().value)   // 是 key 的迭代器，但是这个顺序可以保证么......
    }
    cache.set(key, value)
  }
}
```

### 类似 ORM 框架的链式调用

```javascript
// 实现一个find函数，并且find函数能够满足下列条件

// title数据类型为string|null
// userId为主键，数据类型为number

// 实现一个find函数，并且find函数能够满足下列条件

// title数据类型为string|null
// userId为主键，数据类型为number

// 原始数据
const data = [
  {userId: 8, title: 'title1'},
  {userId: 11, title: 'other'},
  {userId: 15, title: null},
  {userId: 19, title: 'title2'}
];

function find(input) {
  let data = [...input]
  return {
    data: data,
    where(query) {
      const queryKeys = Object.keys(query)
      // filter
      data = data.filter(item => queryKeys.every(queryKey => queryKey instanceof RegExp
              ? query[queryKey].test(item[queryKey])
              : item[queryKey] === queryKey))
      return this;    // this 是指当前这个 obj
    },
    orderBy(key, sort) {
      data.sort((a, b) => sort === 'asc' ? a[key] - b[key] : b[key] - a[key])
      return data;
    },
  }
}

// 查找data中，符合条件的数据，并进行排序
const result = find(data).where({
  "title": /\d$/
}).orderBy('userId', 'desc');

console.log(result)

// 输出
// [{userId: 19, title: 'title2'}, {userId: 8, title: 'title1'}];
```

### 如何实现 position: sticky

relative + fixed + js scroll

还可以通过其附近元素的 mutation observer，intersection observer

### 进制转换

```javascript

function getNums7() {
  var nums7 = [];
  for (let i = 0; i < 7; i++) {
    nums7.push(i)
  }
  return nums7;
}

var convertToBase7 = function (num) {
  const arr = [];
  const nums7 = getNums7();
  let neg = '';//正负
  if (num < 0) {
    neg = '-';
    num = Math.abs(num)
  }
  if (num == 0) {
    return num + "";
  }
  while (num) {
    const res = num % 7;  // 对低位数据进行截取
    arr.unshift(nums7[res]);
    // 进位
    num = parseInt(num / 7);
  }
  arr.unshift(neg);
  return arr.join("");
}
```

## Vue extends 用法

使用基础 Vue 构造器，创建一个“子类”。简单说，就是基于一个 Object 可返回 Vue 的子类，可实例化后进行挂载。

```javascript
Modal.alert = content =>
        new Promise(resolve => {
          const Ctor = Vue.component("UModal");
          if (!Ctor) return;

          let instance = new Ctor({
            propsData: {content, type: ModalType.ALERT, showClose: false, cancelButton: ""},
          });
          instance.$on("ok", () => resolve());
          instance.open();
        });

// 实例open
function open() {
  if (!this.$el) this.$mount(document.createElement("div"));
}
```

## css 居中，再重复一遍

### absolute+transform

### flex、align-items、justify-content

### table-cell

```css
.pagination {
  display: table;
  position: relative;
  width: 200px;
  height: 200px;
}

.pagination p {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
}
```

### absolute+margin

```css
.container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}
```

### absolute+浮动

```css

.pagination ul {
  position: absolute;
  left: 50%;
}

.pagination li {
  float: left;
  position: relative;
  right: 50%;
}
```

## CSRF 不靠 img 或 script 还有什么途径

DNS 重解析攻击

## webpack 热更新

热更新接口（module.hot.xxx）向 Webpack 声明依赖模块和当前模块是否能够更新，以及更新的前后进行的处理。

`module.hot.dispose()` 用于注册当前模块被替换前的处理函数，并且回调函数接收一个 data 对象，可以向其写入需要保存的数据，这样在新的模块执行时可以通过 module.hot.data 获取到：

```javascript
var current = 0;
if (module.hot && module.hot.data) {
  current = module.hot.data.current;
}
```

module.hot.accept() 告诉 Webpack，当前模块更新不用刷新

module.hot.decline() 告诉 Webpack，当前模块更新时一定要刷新

```javascript
if (module.hot) {
  module.hot.accept();
  module.hot.dispose(data => {
    data.current = current;
    stop();
  });
}
```

首先，模块执行时，先检查有没有旧模块留下来的数据，如果有，就恢复。

### plugins 作用于 webpack 哪个生命周期

Compile 开始进入编译环境，开始编译

Compilation 即将产生第一个版本

make 任务开始

optimize 作为 Compilation 的回调方法，优化编译，在 Compilation 回调函数中可以为每一个新的编译绑定回调。

after-compile 编译完成

emit 准备生成文件，开始释放生成的资源，最后一次添加资源到资源集合的机会

after-emit 文件生成之后，编译器释放资源

## 专业地描述概念

### 闭包作用与原理

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使是函数在当前词法作用域外执行。

作用：能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。

原理：基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到。

常见的块级作用域有 with，try/catch，let，const

### 前端模块化规范

CommonJS: 主要是 Node.js 使用，通过 require 同步加载模块，exports 导出内容。

AMD: 主要是浏览器端使用，通过 define 定义模块和依赖，require 异步加载模块，推崇依赖前置。Asynchronous Module Definition

CMD: 和 AMD 比较类似，主要是浏览器端使用，通过 require 异步加载模块，exports 导出内容，推崇依赖就近。Common Module Definition

UMD: 通用模块规范，是 CommonJS、AMD 两个规范的大融合，是跨平台的解决方案。

ESM: 官方模块化规范，现代浏览器原生支持，通过 import 异步加载模块，export 导出内容。

### IEEE754 标准

存储为 64 位，1 符号位，11 指数位，52 小数位。

### TCP 为什么四次挥手

本质的原因是 tcp 是全双工的，要实现可靠的连接关闭，A 发出结束报文 FIN，收到 B 确认后 A 知道自己没有数据需要发送了，B 知道 A 不再发送数据了，自己也不会接收数据了。

但是此时 A 还是可以接收数据，B 也可以发送数据；当 B 发出 FIN 报文的时候此时两边才会真正的断开连接，读写分开。

### 浏览器渲染机制

[http://febook.hzfe.org/awesome-interview/book2/browser-render-mechanism](http://febook.hzfe.org/awesome-interview/book2/browser-render-mechanism)

当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：

PARSE：解析 HTML，构建 DOM 树。

STYLE：为每个节点计算最终的有效样式。

LAYOUT：为每个节点计算位置和大小等布局信息。

PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。

COMPOSITE & RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。

为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。

### V8 垃圾回收机制

V8 中有两个垃圾收集器。

主要的 GC 使用 Mark-Compact 垃圾回收算法，从整个堆中收集垃圾。

小型 GC 使用 Scavenger 垃圾回收算法，收集新生代垃圾。

### 多图网站优化途径

图片优化：进行图片压缩/缩放和选择正确的图片格式。

网络传输优化：使用 HTTP/2 和 CDN 服务。

图片加载策略优化：按需使用懒加载、预加载，响应式图片加载等策略。

#### 另外，图片压缩用户端实现：

将用户上传的图片绘制到 Canvas 画布上，利用 CanvasRenderingContext2D.drawImage(image, dx, dy, dWidth, dHeight) API 进行图片缩放

利用 HTMLCanvasElement.toDataURL(type, encoderOptions) API 进行有损压缩。

### 描述事件循环

浏览器需要事件循环来协调事件、用户操作、脚本执行、渲染、网络请求等。

通过事件循环，浏览器可以利用任务队列来管理任务，让异步事件非阻塞地执行。每个客户端对应的事件循环是相对独立的。

#### 浏览器为什么需要事件循环

由于 JavaScript 是单线程的，且 JavaScript 主线程和渲染线程互斥，如果异步操作阻塞 JavaScript 的执行，会造成浏览器假死。

而事件循环为浏览器引入了任务队列（task queue），使得异步任务可以非阻塞地进行。

```javascript
setTimeout(() => {
  Promise.resolve()
          .then(() => {
            setTimeout(() => {
              console.log("setTimeout 1");
            });
            Promise.resolve().then(() => {
              console.log("then 1");
            });
          })
          .then(() => {
            console.log("then 2");
          });
  console.log("setTimeout 2");
});

// timeout2 then1 then2  timeout1
```

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  return "async return";
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(function () {
  console.log("setTimeout");
}, 0);

async1().then(function (message) {
  console.log(message);
});

new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});

console.log("script end");

/**
 * script start
 async1 start
 async2
 promise1
 script end
 async1 end
 promise2  // 要注意这个比 async1().then 输出 的async return 先，因为当前 .then 先进入微任务队列
 async return
 setTimeout
 */
```

### js 异步编程有哪些方式

异步回调（addEventListener click）

定时器：setTimeout/setInterval/requestAnimationFrame

发布订阅

Promise

生成器

async await

web worker

### HTTP/1.1 的缺点：

队头阻塞（Head-of-line blocking）

头部冗余

TCP 连接数限制

### HTTP/2 的优点：

二进制分帧层

多路复用

Header 压缩

服务端推送

请求优先级

### 四次挥手释放连接时，等待 2MSL 的意义

两个理由：

保证客户端发送的最后一个 ACK 报文段能够到达服务端。（这个 ACK 报文段有可能丢失）

防止“已失效的连接请求报文段”出现在本连接中。

### https 相关

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

（1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成"对话密钥"。 （3） 双方采用"对话密钥"进行加密通信。

#### SSL 协议握手流程

第一步：客户端->服务端

- 客户端支持的 SSL 最高版本号
- 客户端生成的随机数，32字节
- 客户端支持的加密方法
- session id
- 客户端支持的密码套件列表
- 客户端支持的压缩算法列表

第二步：服务端->客户端

- SSL 版本号，取双方各自支持的最高版本号中较低者
- 服务端生成的随机数，32字节
- session id
- 选择的密码套件
- 压缩方法
- 数字证书

第三步：客户端检查证书有效性，生成新的随机数，并使用公钥加密

第四步：服务端使用私钥解密随机数

第五步：根据约定的加密方法，使用前面三个随机数生成对话密钥 session key，接下来对称加密

#### 密钥交换算法

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。

整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

交换算法有 RSA、DH（更加安全）

#### session 的恢复

如果建立的 SSl 连接中断，需要重新握手。

可以用 session ID，或者 session ticket 恢复。

前者客户端给出，服务端确认存在即可继续使用已有的对话密钥，但是如果连接到另一台服务器就无法恢复；

后者使用服务器上一次对话中发来的 session ticket，它是加密的只有服务器能解密，包含对话的主要信息，验证通过即可恢复。不局限于上一次的服务器。

### 从输入URL到页面展示，这中间发生了什么

- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
  + 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
  + 利用ip地址和服务器建立tcp连接
  + 构建请求头信息
  + 发送请求头信息
  + 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
- 网络进程解析响应流程；
  + 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
  + 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
- 准备渲染进程
  + 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
- 传输数据、更新状态
  + 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  + 渲染进程接收完数据后，向浏览器发送“确认提交”
  + 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

### 完整的渲染流程大致可总结为如下

- 渲染进程将HTML内容转换为能够读懂的DOM树结构。
- 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

### V8 是如何执行 js 的

字节码 +JIT 技术

1. 生成抽象语法树AST和执行上下文。生成 AST 分两步：分词（tokenize），又称为词法分析；解析（parse），又称为语法分析

2. 生成字节码。解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码（类似 smail）

3. 通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。

   在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码。

   那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

## 平时没注意的技术/问题

### V8 .sort

v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。

```javascript
[-1, -8, -2, 1, 11, 4].sort() // [-1, -2, -8, 1, 11, 4]  是按 ASCII 排序的，所以应该传入比较函数
```

要打乱数组，不能靠简单的 => Math.random()-0.5。有个洗牌算法可以考虑。

### web 页面的适配

<meta name="viewport">

标准方案：<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">

em、rem(root em)。postcss px2rem

flex 布局

vw vh

### form 表单常用的表单元素

< form name="" action="" method="get">……</form>

< input type="" name="" value="" size="">  type:text password radio checkbox button hidden file color tel url search
email date time

fieldset 定义域（输入框+边框），legend 边框上的文字，不过可能会被 reset

### html 标签共有的属性

class、id、style、title、dir（元素中文本的方向 ltr rtl）、lang(html 标签会使用)。HTML5 新增的属性 draggable、dragzone、hidden、spellcheck 等。

另外，html5 新增的特性：

语义标签（header footer nav section article aside...）、增强型表单（input color 等等）、视频和音频、Canvas绘图、SVG绘图、地理定位、

拖放API、WebWorker、WebStorage、WebSocket

### vue.use() 做了什么

使用vue.use()注册插件，插件可以是一个函数，可以是一个带有install属性的对象。不管是函数还是install方法,第一个参数总是vue对象。

首先先判断插件plugin是否是对象或者函数

判断vue是否已经注册过这个插件 installedPlugins.indexOf(plugin) > -1

取vue.use参数 const args = toArray(arguments, 1)

除第一个参数外（第一个参数是插件 plugin），其他参数都存储到一个数组中，并且将 vue 对象插入到参数数组的第一位。最后参数数组就是[vue,arg1,arg2,...]。

判断插件是否有 install 方法，如果有就执行 install() 方法。没有就直接把plugin当Install执行。（此时install方法内的this指向plugin对象）

### 如何监听页面上的的全部事件

使用monitorEvents()监听事件。例如 `monitorEvents(document.body, "click")`，不传第二个参数则监听全部。

使用unmonitorEvents()停止监听。

使用getEventListeners()获取DOM元素的监听器。

但是这个方案并没有提供回调函数额，或许只能在控制台看到。

### webpack tapable

webpack 中有两个非常重要的内部对象，compiler和compilation对象，在两者的hooks上都事先定义好了不同类型的钩子，这些钩子会在编译的整个过程中在相应时间点时触发。

而自定义插件 hook 这个时间点，并执行相关逻辑。

```javascript
// 1. 它是一个具名的函数或者JS类
class AssetUploadPlugin {
  constructor(options) {
    // 这里可以校验传入的参数是否合法等初始化操作
    assert(
            options,
            "check options ..."
    );
  }

  // 2. 在原型链上指定`apply`方法
  // apply方法接收 webpack compiler 对象入参
  apply(compiler) {
    // 3. 指定一个明确的事件钩子并注册回调
    compiler.hooks.afterEmit.tapAsync(  // 因为afterEmit是AsyncSeriesHook类型的钩子，需要使用tapAsync或tapPromise钩入回调
            "AssetUploadPlugin",
            (compilation, callback) => {
              // .......
              callback();
            })
  }
}
```

### Long Tasks API

它可以直观地告诉我们哪些任务执行耗费了 50 毫秒或更多时间，做性能监控 sdk 可能用得上

```javascript
var observer = new PerformanceObserver(function (list) {
  var perfEntries = list.getEntries();
  for (var i = 0; i < perfEntries.length; i++) {
    // Process long task notifications:
    // report back for analytics and monitoring
    // ...
  }
});
// register observer for long task notifications
observer.observe({entryTypes: ["longtask"]});
// Long script execution after this will result in queueing
// and receiving "longtask" entries in the observer.
```

### vue 中 this.$set 做了什么事

defineReactive(ob.value, key, val)  // 给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染

ob.dep.notify() // 触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。

### vue 数组不能直接更改下标更新

大概是性能考虑？

对数组 defineProperty 是可以做的，但是会有问题，改变了数组长度，排序等等。

### typeof NaN === 'number'

### this 指向的优先级

New 绑定 > 显示绑定 > 隐式绑定 > 默认绑定

如果是 new 一个硬绑定函数，那么会用 new 新建的对象替换这个硬绑定 this

```javascript
function foo(a) {
  this.a = a;
}

var bar = new foo(2);
console.log(bar.a)
```

new 绑定的优先级高于 bind 显示绑定。因此，如果一个构造函数，bind了一个对象，用这个构造函数创建出的实例不会继承这个对象的属性

### script 标签加载外部 js 文件与 onload 顺序

完成所有加载后，才触发 onload

### UI 渲染 也是宏任务

### instanceof 右边只能是函数（？）

`'hello tuture' instanceof String // false`

### setTimeout 任务加入队列

是等 timeout 后才加入等待队列

### 浏览器的 history

history.pushState(state, title[, url]) 方法向当前浏览器会话的历史堆栈中添加一个状态（state）。

浏览器不会在调用pushState() 之后尝试加载此URL，但可能会稍后尝试加载URL，例如在用户重新启动浏览器之后。

新网址必须与当前网址相同 origin； 否则，pushState()将引发异常。 如果未指定此参数，则将其设置为文档的当前URL。

replaceState()方法使用state objects, title,和 URL 作为参数， 修改当前历史记录实体。新的URL跟当前的URL必须是同源; 否则 replaceState 抛出一个异常.

### js 中可以触发自定义事件

```javascript
elem.addEventListener('build', function (e) {
}, false);

const event = new Event('build');
elem.dispatchEvent(event);
```

### weakmap 为什么可以不影响垃圾回收

TODO

应该是给对象设置了特殊的属性？那数组呢

### 盒模型

W3C 盒子模型（content-box），width 只算 content，不算 padding。

IE 的（border-box），算到 border，不算 margin.

### @babel/plugin-transform-runtime 作用？

babel 在转译的过程中，对 syntax 的处理可能会使用到 helper 函数，对 api 的处理会引入 polyfill。

默认情况下，babel 在每个需要使用 helper 的地方都会定义一个 helper，导致最终的产物里有大量重复的 helper；引入 polyfill 时会直接修改全局变量及其原型，造成原型污染。

@babel/plugin-transform-runtime 的作用是将 helper 和 polyfill 都改为从一个统一的地方引入，并且引入的对象和全局变量是完全隔离的，这样解决了上面的两个问题。

### Webpack

Webpack 支持 ES6 Module、CommonJS 和 AMD 等模块化方法，目前常用的是 ES6 Module 和 CommonJS。ES6 Module 和 CommonJS 都支持同步和异步导入模块。

ES6 Module 通过 export 导出模块，import … from '…'或 import '…'同步导入模块。

CommonJS 通过 module.exports 导出模块，require('…')同步导入模块。

ES6 Module 通过 import()函数异步导入模块，CommonJS 通过 require.ensure 异步导入模块，现在推荐使用 import()函数异步导入模块。

webpack 的预处理器 loader 是从后向前的。

### webpack - 打包速度优化

分析耗时 speed-measure-webpack-plugin .wrap(webpackConfig)，检查是不是有重复 polyfill

减小文件搜索范围（设置别名；设置 test & include & exclude）

webpack.optimize.UglifyJsPlugin 是单线程，可以换 webpack-parallel-uglify-plugin

Happypack 多进程执行 loader

设置缓存

大型类库设置 noParse（不扫描新依赖）

DLL

hard-source

### DOM 事件中的 currentTarget

而对于 currentTarget，它指的是当事件遍历DOM时，标识事件的当前目标。

它总是引用事件处理程序附加到的元素，而不是event.target，它标识事件发生的元素。

### Babel 是如何把 ES6 转成 ES5

1. 将代码字符串解析成抽象语法树，即所谓的 AST
2. 对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
3. 根据处理后的 AST 再生成代码字符串

使用 @babel/parser 的 parse 方法，将代码字符串解析成 AST

使用 @babel/core 的 transformFromAstSync 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串

过程中，可能还需要使用 @babel/traverse 来获取依赖文件等。

也可以引入 polyfill

### vue 父子组件的生命周期顺序

父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

1.当父组件执行完beforeMount挂载开始后，会依次执行子组件中的钩子，直到全部子组件mounted挂载到实例上，父组件才会进入mounted钩子

2.子级触发事件，会先触发父级beforeUpdate钩子，再去触发子级beforeUpdate钩子，下面又是先执行子级updated钩子，后执行父级updated钩子

子组件先于父组件mounted

### 缓存 - 返回了 Cache-Control:no-cache，也是会走协商缓存的

### HTML5 的离线存储

HTTP缓存：强缓存资源可离线使用

基于一个manifest文件(缓存清单文件，一般后缀为.appcache)的缓存机制，其中定义了需要缓存的文件。

可以用于离线浏览，减少服务端负载。

Service Worker： self.addEventListener('fetch',

### padding-top: 50%; height: 0; 为啥可以使子元素高度是父级一半？

```css
 .father {
  position: relative;
  width: 500px;
  height: 300px;
  margin: auto auto 2rem;
  background: lightskyblue;
}

.square_2 {
  width: 50%;
  padding-top: 50%;
  height: 0;
  background: indianred;
}
```

#### 如何实现一个宽度自适应，高度为宽度的一半的矩形

首先要明白，padding-top/bottom和margin-top/bottom都是相对于父元素的宽度来计算的

最简单版本：

```html

<div class="scale"></div>
```

```css
.scale {
  width: 100%;
  height: 0;
  padding-bottom: 50%;
  background: gray;
}
```

将元素的高度由padding撑开，由于padding是根据父元素宽度计算的，所以高度也就变成了相对父元素宽度，同时要将height设置为 0，这是为了将元素高度完全交给padding负责。

最后padding-bottom的值设为width的值一半，就可以实现高度是宽度的一半且自适应

#### 优化

元素的height为 0，导致该元素里面再有子元素的时候，就无法正常设置高度。所以需要用到position: absolute;

```html

<div class="scale">
  <div class="item">
    这里是所有子元素的容器
  </div>
</div>
```

```css
.scale {
  width: 100%;
  padding-bottom: 56.25%;
  height: 0;
  position: relative;
}

.item {
  width: 100%;
  height: 100%;
  background-color: aquamarine;
  position: absolute;
}
```

### js 函数传参

基本类型是值传递的，拷贝了一份。

### electron 主进程与渲染进程通信

#### ipcMain、ipcRender

#### remote

这个 ipc 的原理？[https://imweb.io/topic/5b3b72ab4d378e703a4f4435](https://imweb.io/topic/5b3b72ab4d378e703a4f4435)

类似于 类似于 Java 中的 RMI（Remote Method Invoke）

remote 模块不仅帮我们实现了 IPC 通信，同时为了达到类似引用传递的效果，使用了类似 Java 中的
RMI，对主进程的对象进行了一层封装，使得我们在访问远程对象上的属性时，也需要向主进程发送同步进程消息来获取到当前主进程上该对象实际的值。

### 浏览器性能指标

#### FP、FCP

FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。

相比之下，FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。

注意：FP不包含默认背景绘制，但包含非默认的背景绘制。

只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作FCP。

#### FMP

FMP本质上是通过一个算法来猜测某个时间点可能是FMP，所以有时候不准

#### LCP

```javascript
const observer = new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();
  const lastEntry = entries[entries.length - 1];
  const lcp = lastEntry.renderTime || lastEntry.loadTime;
  console.log('LCP:', lcp)
});
observer.observe({entryTypes: ['largest-contentful-paint']});
```

查看 “绘制面积” 最大的元素何时开始渲染。

所谓绘制面积可以理解为每个元素在屏幕上的 “占地面积”，如果元素延伸到屏幕外，或者元素被裁切了一部分，被裁切的部分不算入在内，只有真正显示在屏幕里的才算数。

图片元素的面积计算方式稍微有点不同，因为可以通过CSS将图片扩大或缩小显示，也就是说，图片有两个面积：“渲染面积”与“真实面积”。

在LCP的计算中，图片的绘制面积将获取较小的数值。例如：当“渲染面积”小于“真实面积”时，“绘制面积”为“渲染面积”，反之亦然。

页面在加载过程中，是线性的，元素是一个一个渲染到屏幕上的，而不是一瞬间全渲染到屏幕上，所以“渲染面积”最大的元素随时在发生变化。如果使用 PerformanceObserver
去捕获LCP，会发现每当出现“渲染面积”更大的元素，就会捕获出一条新的性能条目。

该过程将持续到用户第一次滚动页面或第一次用户输入（鼠标点击，键盘按键等），也就是说，一旦用户与页面开始产生交互，则停止报告新的性能条目。

如果元素被删除，LCP算法将不再考虑该元素，如果被删除的元素刚好是 “绘制面积” 最大的元素，则使用新的 “绘制面积” 最大的元素创建一个新的性能条目。

元素被删除后不能被认为是面积最大主要是解决“启动画面”问题。

可能存在的问题：

1. 该算法在检查到用户与页面产生交互时停止。如果用户很早就开始与网页产生交互，该算法将会捕获错误的结果或者没有结果。

2. 由于元素一旦删除就不能被视为是面积最大，所以在具有大图片轮播的页面中会出现问题。如果在绘制下一张图时，当前图片被删除，并且下一张图被认为是面积最大，那么算法将基于轮播图不断更新LCP。

#### 其他不常用的

TTI（全称“Time to Interactive”，翻译为“可交互时间”） 表示网页第一次 完全达到可交互状态 的时间点。

TTFB（全称“Time to First Byte”） 表示浏览器接收第一个字节的时间

FCI（全称“First CPU Idle”） 是对TTI的一种补充，TTI可以告诉我们页面什么时候完全达到可用，但是我们不知道浏览器第一次可以响应用户输入是什么时候。

更通俗的理解TTI与FCI的区别：FCI代表浏览器真正的第一次可以响应用户的输入，而TTI代表浏览器已经可以持续性的响应用户的输入。

FID（全称“First Input Delay”，翻译为“首次输入延迟”）

DCL 表示DomContentloaded事件触发的时间

博客文章这样的页面更侧重FMP（用户希望尽快看到有价值的内容），而类似后台管理系统或在线PPT这种产品则更侧重TTI（用户希望尽快与产品进行交互）。

Cumulative Layout Shift 累积布局偏移(CLS)

### 是否可以对零尺寸元素使用 零尺寸元素 Intersection Observer？

TODO

### 不定高的列表虚拟滚动如何定位？

先设置大致高度，靠 ResizeObserver（MutationObserver）

[https://lkangd.com/post/virtual-infinite-scroll/](https://lkangd.com/post/virtual-infinite-scroll/)

### 布局抖动、强制同步布局

让你的网页更丝滑（全）  [https://github.com/berwin/Blog/issues/39](https://github.com/berwin/Blog/issues/39)

js改了样式，其实它是异步的去计算样式，布局，绘制，图层合并，每一步都是异步的。

但是有时候一不小心就会出现一个词叫做强制同步布局

> 获取布局信息时，会导致重排。相关的方法属性如 offsetTop getComputedStyle 等

当执行 container.offsetWidth 时浏览器由于不知道元素的宽度是多少，但我现在马上就要知道这个元素的宽度是多少，所以这个布局不能异步；

那么为了告诉我这个元素有多宽，必须马上执行一次同步的布局操作，而随后的代码中又设置了元素的宽度，这其实就是要把刚刚执行的布局给否定掉，让布局失效。

当下一轮循环又执行到 container.offsetWidth 读取元素的宽时，由于刚刚执行了设置元素的宽，所以浏览器又不知道当前元素的宽度是多少，所以它又要做一次强制同步布局。

所以浏览器在不停的布局，让布局失效，布局，让布局失效直到循环结束。

### Number 上的属性/方法?

#### MIN_SAFE_INTEGER、MAX_SAFE_INTEGER、isSafeInteger()

Javascript 的数字存储使用了 IEEE 754 中规定的双精度浮点数数据类型，而这一数据类型能够安全存储 -(253 - 1) 到 253 - 1 之间的数值（包含边界值）。

这里安全存储的意思是指能够准确区分两个不相同的值，例如 Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 将得到 true的结果，而这在数学上是错误的

#### Number.MAX_VALUE

值接近于 1.79E+308。大于 MAX_VALUE 的值代表 "Infinity"。

#### Number.EPSILON

表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。接近 2.22E-16，或者 2^-52。

Math.abs(0.2 - 0.3 + 0.1) < Number.EPSILON // true

#### Number.isNaN()

该方法确定传递的值是否为 NaN，并且检查其类型是否为 Number。它是原来的全局 isNaN() 的更稳妥的版本。

它不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。

isNaN(undefined) => true

Number.isNaN(undefined) => false

```javascript
// polyfill
Number.isNaN = Number.isNaN || function (value) {
  return typeof value === "number" && isNaN(value);
}
```

### 不常用的跨域方式的实现细节

#### postMessage

即在两个 origin 下分别部署一套页面 A 与 B，A 页面通过 iframe 加载 B 页面并监听消息，B 页面发送消息。

#### window.name

主要是利用 window.name 页面跳转不改变的特性实现跨域，即 iframe 加载一个跨域页面，设置 window.name，跳转到同域页面，可以通过 $('iframe').contentWindow.name 拿到跨域页面的数据。

#### document.domain

- 可将相同一级域名下的子域名页面的 document.domain 设置为一级域名实现跨域。
- 可将同域不同端口的 document.domain 设置为同域名实现跨域（端口被置为 null）。

### overflow

默认属性是 visiable。

overlay 行为与auto相同，但滚动条绘制在内容之上而不是占用空间。

设置一个轴为visible（默认值），同时设置另一个轴为不同的值，会导致设置visible的轴的行为会变成auto。

即使将overflow设置为hidden，也可以使用JavaScript Element.scrollTop 属性来滚动HTML元素。

### vue diff

是广度优先（只会在同层级进行，不会跨层级比较），复杂度 O(n)

1. 只比较同一级，不跨级比较
2. tag不相同，直接删掉重建，不再深度比较
3. tag和key，两者都相同，则认为是相同节点，不在深度比较

#### 双端比较的优势？

双端比较在移动 DOM 方面更具有普适性，不会因为 DOM 结构的差异而产生影响。

#### 设置 key 有什么作用？

1. key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。

2. 另外，若不设置key还可能在列表更新时候引发一些隐藏的bug。

3. vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。

不能用 index 做 key：当用index作为key的时候，删除节点后面的所有节点都会导致重新渲染

### Js 继承

#### 原型链继承的缺点

```javascript
function Dog() {
}

Dog.prototype = new Animal(); // 记一下这个方式
const dogA = new Dog();
```

原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现；

缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。

#### ES6中的class继承的实现原理

基于寄生组合继承来实现的

```javascript
subType.prototype = Object.create(superType.prototype);               // 将子类的原型替换为这个原型
prototype.constructor = subType;             // 修正原型的构造函数

// subType 内部：
SuperType.call(this, name);
```

### js 的栈溢出？

- 每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。
- 如果在一个函数A中调用了另外一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

### 变量提升、作用域

[https://blog.poetries.top/browser-working-principle/guide/part2/lesson10.html#作用域链](https://blog.poetries.top/browser-working-principle/guide/part2/lesson10.html#作用域链)

```javascript
showName()
console.log(myname) // 输出 undefined，提前声明但赋值为 undefined
var myname = 'demo'

function showName() {
  console.log('函数showName被执行');
}
```

```javascript
let myname = 'aaa'
{
  console.log(myname) // Uncaught ReferenceError: Cannot access 'myname' before initialization
  // let关键字会创建块级作用域，暂时性死区  
  let myname = 'bbb'
}
```

```javascript
let myname = 'aaa'
{
  console.log(myname)// aaa
}
```

```javascript
function bar() {
  console.log(myName)
}

function foo() {
  var myName = "foo name"
  bar()
}

var myName = "main name"
foo()
```

上面的示例最终输出 main name，而不是 foo name

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。

bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。

foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的

因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。

也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

### setTimeout 的细节

嵌套设置 settimeout 时：前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。

之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。

未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

```javascript
var name = 1;
var MyObj = {
  name: 2, showName: function () {
    console.log(this.name);
  }
}
setTimeout(MyObj.showName, 1000)
```

输出的是 1，可以改成函数再调用，或者bind

### setInterval 是什么时候添加下一次调用的？

按定时间隔设置的调用频率，而不是回调函数执行完成后设置下一次的。

### Promise、微任务

执行微任务过程中创建的微任务，会在当前微任务队尾立即执行。宏任务没有这个特性

Promise 采用了回调函数延迟绑定技术，为了效率，是微任务。

promise 的 catch的异常穿透是一层层传递下来的并非一次失败状态直接传递到catch，前面的 then 如果传了第二个参数，也会走的。

打断 promise 链，返回一个 pending 的 promise 即可

### css 的属性继承

#### 可以继承的属性

字体系列属性、文本系列属性（text-align、line-height、direction、color）、visibility、cursor

#### 不可继承的属性

display、vertical-align、text-decoration

盒模型的属性（width、height、margin、border...）

背景属性、定位属性

#### line-height:2、2em、200% 的区别

1、line-height:2em、line-height:200%

根据父元素的字体大小计算行高

子元素继承父元素计算后的行高，如果子元素的字体很大，而父元素字体小，这样计算出来的行高有可能无法容量子元素的显示，会被截掉。

2、line-height:2（推荐）

根据子元素计算行高（取最大字体值*2）

### v8对使用内存的限制

64位系统是1.4G，32位系统是0.7G

### web component 提供了什么

- Custom elements

自定义元素，通过使用对应的api，用户可以在不依赖框架的情况下，开发原生层面的自定义元素，最关键的是，它将包含独立的生命周期，以及提供了自定义属性的监听。这就意味着它也同样具备了较高的可操作性。

- Shadow DOM

影子dom(最大的特点是不暴露给全局)，可以通过对应的api，将shadow dom附加给自定义元素，并控制其相关功能。利用shadow dom的特性，起到隔离的作用，使特性保密，不用再担心所编写的脚本及样式与文档其他部分冲突。

- HTML模版

通过<template/>、<slot/>去实现内容分发。回忆一下vue的插槽(slot)和react的props.children。

#### 声明一个 web component

```javascript
//自主定制元素 
class CustomEle extends HTMLElement {
  constructor() {
    super();
  }
}

customElements.define('custom-ele', CustomEle);

//自定义内置元素，如果要扩展div的话 
class CustomEleBuiltIn extends HTMLDivElement {
  constructor() {
    super();
  }
}

customElements.define('custom-ele-build-in', CustomEleBuiltIn, {extends: 'div'}); 
```

### 循环中正确地使用 await

[https://juejin.cn/post/6844903860079738887](https://juejin.cn/post/6844903860079738887)

for 循环可以正常用 await 等待

forEach、map、filter 等不能，不过可以先 map 得到 promise array，然后 await 它。

#### for await ... of

类似于 await 运算符一样，该语句只能在一个async function 内部使用。

for await...of 不适用于不是异步可迭代的异步迭代器。

异步生成器已经实现了异步迭代器协议, 所以可以用 for await...of循环：

```javascript
async function* asyncGenerator() {
  var i = 0;
  while (i < 3) {
    yield i++;
  }
}

(async function () {
  for await (num of asyncGenerator()) {
    console.log(num);
  }
})();
// 0
// 1
// 2
```

可以迭代一个明确实现异步迭代协议的对象：

```javascript
var asyncIterable = {
  [Symbol.asyncIterator]() {
    return {
      i: 0,
      next() {
        if (this.i < 3) {
          return Promise.resolve({value: this.i++, done: false});
        }

        return Promise.resolve({done: true});
      }
    };
  }
};

(async function () {
  for await (num of asyncIterable) {
    console.log(num);
  }
})();

// 0
// 1
// 2

```

### ECMA 提案的阶段

[https://tc39.es/zh-Hans/](https://tc39.es/zh-Hans/)

从 Stage 0（Strawman，初稿）开始，经 Stage 1（提案）、Stage 2（草案）、Stage 3（候选提案），最后到 Stage 4（Finished，过审提案）结束

+ stage-0：还是一个设想，只能由TC39成员或TC39贡献者提出

+ stage-1:：提案阶段，比较正式的提议，只能由TC39成员发起，这个提案要解决的问题必须有正式的书面描述。

+ stage-2：草案，有了初始规范，必须对功能语法和语义进行正式描述，包括一些实验性的实现。

+ stage-3：候选，该提议基本已经实现，需要等待实验验证，用户反馈及验收测试通过。

+ stage-4：已完成，必须通过 Test262 验收测试，下一步就纳入ECMA标准。

按照TC39 流程文档，应该是每年 7 月发版： July: Approval of new standard by the ECMA General Assembly

但实际发版时间是每年 6 月，可能是为了纪念历史上那些 6 月发布的元老版本

### webRtc 是如何建立连接的

依赖信令服务器获知会话描述信息 RTCSessionDescription（SDP）

WebRTC 通过ICE框架确定两端建立网络连接的最佳路径，为开发者者屏蔽了复杂的技术细节。

ICE两端并不知道所处的网络的位置和 NAT 类型，通过ICE能够动态的发现最优的传输路径。ICE 端收集本地地址、通过STUN服务收集 NAT 外网地址、通过TURN收集中继地址，所以会有三种候选地址：

- host 类型，即本机内网的 IP 和端口；

- srflx 类型, 即本机 NAT 映射后的外网的 IP 和端口；

- relay 类型，即中继服务器的 IP 和端口。

### 为什么css动画比JavaScript高效

通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。

合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。

但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存。

### 问体验性能优化，可以按页面的阶段考虑

#### 加载阶段

总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数

#### 交互阶段

1. 减少 JavaScript 脚本执行时间，有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。

一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。

另一种是采用 Web Workers。

2. 避免强制同步布局

所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中

新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。

如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。

3. 避免布局抖动

所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。

会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。

4. 合理利用 CSS 合成动画

合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。

如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。

5. 避免频繁的垃圾回收

垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。

可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。

### canvas vs svg

SVG是可缩放矢量图形的文档格式。 Canvas是一个JavaScript API，用于将矢量图形绘制为特定大小的位图。

Canvas 的性能受画布尺寸影响更大，而SVG 的性能受图形元素个数影响更大。

而且在小数据量的情况下，SVG 的方案通常内存占用会更小，做缩放、平移等操作的时候往往帧率也更高。

svg不利于性能，因为它使用真实的dom来不断更新导致回流的对象；canvas不利于使用，因为它没有将对象作为单个实体进行跟踪。

### svg vs iconfont

icon font采用的是字体渲染，icon font在一倍屏幕下渲染效果并不好，在细节部分锯齿还是很明显的

SVG 是图形所以在浏览器中使用的是图形渲染，所以SVG却没有这种问题

### IndexedDB

键值对储存

异步读写

储存空间大，储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限

支持二进制储存，不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。

### Tree Shaking

借助静态模块分析，Tree-Shaking 实现的大体思路：

借助 ES6 模块语法的静态结构，通过编译阶段的静态分析，找到没有引入的模块并打上标记，然后在压缩阶段利用像 uglify-js 这样的压缩工具删除这些没有用到的代码。

Tree shaking 只会对采用 ES6 Module 规范的模块生效

Tree shaking 对会产生副作用的模块不能准确识别, 无法筛去:尽量编写无副作用的函数

但对于 polyfill 这种不 export 而是直接影响全局环境的模块, tree shaking 会直接筛去：在 package.json 或 module.rules 中配置 sideEffects 选项指定会产生副作用的文件;

### webpack 懒加载 原理

webpack打包完的bundle.js， 是一个自执行函数，参数是一个module对象。

module对象里是我们在项目里的import或者require的文件，key是文件相对于根路径的path, value是function函数，里面包含了我们在写在文件里的内容。

过程：首先import()语句会先被转换 require.ensure。如下：

```javascript
import(/* webpackChunkName: "test" */'./test.js').then();
require.ensure('test').then(require('./test.js')).then()
```

require.ensure 首先会根据传入 chunkId, 去找到文件地址，然后用jsonp的方式，将js加载，同时返回promise等待异步js的下载。

```javascript
let installedChunks = {};  //记录加载的模块的信息。
function requireEnsure(chunkId) {
  // ........
  //使用jsonp的方式来进行js文件的加载
  let script = document.createElement('script');
  script.src = jsonpScriptSrc(chunkId);
  document.head.append(script)
  return Promise.all(promises);
}
```

js 加载返回的是 `window["webpackJsonp”].push(…)`

然后就是正常的模块加载了，稍微不同的是import()加载的模块都会被转成webpack里es6的module的形式。

### cache-control 更多的取值？

no-cache: 数据内容不能被缓存, 每次请求都重新访问服务器, 若有max-age, 则缓存期间不访问服务器.

no-store: 不仅不能缓存, 连暂存也不可以(即: 临时文件夹中不能暂存该资源).

private(默认): 只能在浏览器中缓存, 只有在第一次请求的时候才访问服务器, 若有max-age, 则缓存期间不访问服务器.

public: 可以被任何缓存区缓存, 如: 浏览器、服务器、代理服务器等.

max-age: 相对过期时间, 即以秒为单位的缓存时间.

no-cache, private: 打开新窗口时候重新访问服务器, 若设置max-age, 则缓存期间不访问服务器.

private, 正数的max-age: 后退时候不会访问服务器.（例如订单提交后防止浏览器回退重新提交）

no-cache, 正数的max-age: 后退时会访问服务器.

### webpack 中 bundle、module、chunk 是什么

module 就是没有被编译之前的代码

通过 webpack 的根据文件引用关系生成 chunk 文件

webpack 处理好 chunk 文件后，生成运行在浏览器中的代码 bundle

Module 读音 'mɑːdʒul，不是 ˈmɔdl

### es6 module vs commonjs

CommonJS 是对模块的浅拷贝，ES6 Module 是对模块的引用，即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似 const

import 的接口是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。

### sourcemap

映射构建前后的源码

VLQ 编码，Variable-length quantity 的缩写，是一种通用的、使用任意位数的二进制来表示一个任意大的数字的一种编码方式。

配置项：

- eval： 使用eval包裹模块代码

- source-map： 产生.map文件

- cheap： 不包含列信息，也不包含loader的sourcemap

- module： 包含loader的sourcemap（比如jsx to js ，babel的sourcemap）

- inline： 将.map作为DataURI嵌入，不单独生成.map文件（这个配置项比较少见）

### vue 如何实现的解析双大括号模板

1. 首先根据正则获取组件中所有的{{}}，将{{}}里的值取出在data中取出对应的值，以文本节点的方式放上去。

2. vue有内置的编译器，会将组件转译成AST

3. AST会根据generate得到render函数

4. 然后根据 render function 方法最终返回string

5. 最后通过vue的_update方法转化成对应的DOM

### vue-router history 时，nginx 如何配置

```text
location / { 
        root            /data/www/demo; 
        index           index.html; 
        try_files       $uri $uri/ /index.html; 
}
```

请求 `http://localhost:8080/home` 这个地址时，首先查找有无home这个文件，没有；

再查找有无home目录，也没有。所以最终会定位到第三个参数从而返回index.html，按照这个规则，所有路由里的url路径最后都会定位到index.html。

vue-router再获取参数进行前端页面的变换，至此，可以通过 `http://localhost:8080/home` 这个地址进行成功地访问了。

而$uri这个参数的作用其实是匹配那些.js文件用的，而$uri/在这个例子中并没有多大用，实际上是可以去掉的。

### rem 实践

```javascript
// 基准大小
const baseSize = 37.5; // 注意此值要与 postcss.config.js 文件中的 rootValue保持一致
// 设置 rem 函数
function setRem() {
  // var dpr = window.devicePixelRatio || 1 // 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值
  // 当前页面宽度相对于 375宽的缩放比例，可根据自己需要修改,一般设计稿都是宽750(图方便可以拿到设计图后改过来)。
  const scale = document.documentElement.clientWidth / 375;
  // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整）
  document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + "px"; // 或者取 html
}

// 初始化
setRem();
// 改变窗口大小时重新设置 rem
window.onresize = function () {
  setRem();
};
```

### nodejs 项目打包

在node环境下打包，在webpack打包后生成的代码，必须保留require这个关键字，那么就不能把node_modules里面的文件打包进源码中，否则就不是commonjs或es6模块化规范了，node的代码就跑不起来了。

webpack的原理和nodejs运行、以及需求，是冲突的。所以不能通过webpack把node_modules代码打包进nodejs项目源码中

使用了pkg这个库来打包解决问题，pkg是为在容器中使用而创建的

可以将 Node.js 项目打包为可执行文件，即使在未安装 Node.js 的设备上也可以运行该可执行文件。（默认情况下，源代码在写入输出文件之前会预编译为 v8 字节码）

### 常用的vuex的api

+ store.registerModule('c',{}) //注册一个模块

+ store.unregisterModule('c') //解绑一个模块

+ store.subscribe() //订阅，每次mutations被调用，这个api都会被调用

+ store.subscribeAction() //监听actions

+ store.watch() //每次state改变之后都会调用

Reactively watch fn's return value, and call the callback when the value changes.

fn receives the store's state as the first argument, and getters as the second argument.

Accepts an optional options object that takes the same options as Vue's vm.$watch method.

To stop watching, call the returned unwatch function.
