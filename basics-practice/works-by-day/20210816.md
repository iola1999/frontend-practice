## promise上的方法

除了 then、catch、finally，还有 all allsettle race resolve reject any 等等

race 是指任一个状态改变，any 是指任一个成功的，如果都没成功是 rejected

## 模块化规范

### AMD、CMD

依赖前置（ahead？）

比较两者的异同？

+ 相同：都是js模块化的异步加载方式

+ 不同：可以看出AMD规范是在所有以来文件加载完毕之后才执行回调函数，cmd是按需加载，代码执行到了就加载

AMD 缺点：

+ 前期模块初始化的时间相对较长（需要加载所有依赖的文件）

+ 如果某一个依赖文件出错，会导致整个代码无法执行，资源浪费（双刃剑）

+ 有时候加载的依赖项由于代码变更可能会没被用到（else,case分支），但是忘记修改，会造成资源浪费

AMD 优点：

+ 提前加载依赖文件可以提前发现错误，解决问题（双刃剑）

CMD 优点： 延迟按需加载，代码执行到了就加载，可节省资源（用不到的就不加载）

CMD 缺点： 不能提前暴露错误，降低开发效率

### commonJS

commonJS服务器端（nodeJS）的js模块规范,同步加载方式。因为nodeJS会被部署在服务端不存在js模块下载阻塞的问题，但是浏览器则是本地客户机存在下载js文件阻塞的问题。

### UMD

更像是一种语法糖首先判断程序环境是否是nodeJS环境。如果是就使用commonJS规范，在判断是否支持AMD，如果是就使用AMD规范，否则就全局注册。

```javascript
function a(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
        ? define(factory)
        : (global.Vue = factory());
}
```

### ES6模块化规范

使用import/export语法，在文件顶部导入需要的模块，特点是：静态化。

在编译时候(这决定 import 不能放在执行代码中)确定模块之间的以来关系，以及输入输出变量。

### 总结下提前确定依赖关系的

commonJS,AMD,CMD 都是在执行阶段导入模块，确定依赖关系。
