## css position

### fixed 定位

元素的位置相对于浏览器窗口是固定位置。

即使窗口是滚动的它也不会移动：

注意： Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。

Fixed定位使元素的位置与文档流无关，因此不占据空间。

Fixed定位的元素和其他元素重叠。

### relative 定位

相对定位元素的定位是相对其正常位置。

移动相对定位元素，但它原本所占的空间不会改变。

相对定位元素经常被用来作为绝对定位元素的容器块。

### absolute 定位

绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:

absolute 定位使元素的位置与文档流无关，因此不占据空间。

absolute 定位的元素和其他元素重叠。

### sticky 定位

基于用户的滚动位置来定位。

粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。

它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。

元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

## css 两栏布局

这里有详细的解释：[https://www.imooc.com/article/272328](https://www.imooc.com/article/272328)

### 浮动布局：左浮动 右 mergin-left

```css
.one {
    float: left;
    width: 200px;
    height: 200px;
    background: darkcyan
}

.two {
    margin-left: 200px;
    height: 200px;
    background: salmon
}
```

### 浮动布局+负外边距

```html

<div class="aside"></div>
<div class="main">
    <div class="content"></div>
</div>
```

```css
.aside {
    width: 300px;
    height: 100px;
    background: darkcyan;
    margin-right: -100%;
    float: left;
}

.main {
    width: 100%;
    float: left;
}

.content {
    margin-left: 300px;
    background: salmon;
}
```

### 绝对定位

```css
.left {
    width: 200px;
    height: 200px;
    position: absolute;
    background: darkcyan
}

.right {
    height: 200px;
    margin-left: 200px;
    background: salmon;
}
```

### flex

父元素设置display:flex;和justify-content:space-bettween;(两端对齐)

父元素根据需要设置align-item:center;以实现垂直居中

图片固宽元素不需要特殊设置，宽高即可

流体文案设置flex:1;自动分配剩余空间。

轻松弹性，垂直居中不是事儿。

### table 布局

甚至不需要 css，结构放到 table 中，两列分别放到两个td中，固宽的td设置一个宽度即可

二者间距使用任何一个td设置左或右边距即可。

同样实现了垂直居中布局

### 可以使用 display: table-cell 伪造表格布局

### calc

```css
.right {
    width: calc(100% - 200px);
}
```

## 驼峰、下划线的转换

```javascript
'entrustStatusName'.replace(/([A-Z])/g, '_$1').toLowerCase();

'entrust_status_name'.replace(/_(\w)/g, (_, letter) => letter.toUpperCase());   // _ 是 _s，letter 是捕获的内容
```

## Vue 源码大致流程

构造函数阶段、初始化、挂载、更新、销毁

[https://www.jianshu.com/p/a02445759a2c](https://www.jianshu.com/p/a02445759a2c)

## http/2

### 编码

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。

HTTP/1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。

HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

### 管道机制与复用

HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

http/1.1 的管道机制（一个 TCP 连接，可以同时发送多个请求），要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。

对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2的多路复用解决。

HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。
每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后再组装成消息，这样就避免了请求/响应阻塞。

多路复用。代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。

### 其他

服务器推送。服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。

头部压缩。原理是 静态霍夫曼代码。

请求优先级， 设置数据帧的优先级，让服务器优先处理。

## QUIC

基于UDP的多路传输（单连接下）；

极低的等待时延（相比于TCP的三次握手）；

快速迭代更新；

开源于Chromium项目中。

### 为什么不用TCP

TCP由于基于操作系统内核实现，发展速度极慢

TCP采用 重传 机制，而QUIC采用 纠错 机制。如果发生丢包的话，TCP首先需要一个等待延时来判断发生了丢包，然后再启动重传机制，在此期间会对连接造成一定的阻塞。

并且TCP窗口是缓慢增大的，Web这种突发性快速连接情况下窗口会相对较小，从而影响传输时间。

而QUIC采用了一种脑洞极大的前向纠错（FEC）方案，类似于RAID5，将N个包的校验和（异或）建立一个单独的数据包发送，这样如果在这N个包中丢了一个包可以直接恢复出来，完全不需要重传，有利于保证高速性，N可以根据网络状况动态调整。

### 优势

多路复用、等待时延低、加密技术（各种防御措施）、前向纠错、速率控制而非拥塞控制、连接保持

### 防止反射攻击的措施

要求第一个包必须大于多少字节（TODO）、服务端认为不可信时要求验证。

## Webpack

Webpack支持ES6 Module、CommonJS和AMD等模块化方法，目前常用的是ES6 Module和CommonJS。ES6 Module和CommonJS都支持同步和异步导入模块。

ES6 Module通过export导出模块，import … from '…'或import '…'同步导入模块。

CommonJS通过module.exports导出模块，require('…')同步导入模块。

ES6 Module通过import()函数异步导入模块，CommonJS通过require.ensure异步导入模块，现在推荐使用import()函数异步导入模块。

webpack 的预处理器 loader 是从后向前的。

## 对 webpack 的优化

DLLPlugin

多线程构建

hard-source

## 事件触发顺序

在浏览器中，事件的触发顺序一般而言依据：捕获->目标阶段->冒泡三个顺序。

但事件的触发顺序并不总是按以上顺序执行，当我们给同一个DOM元素同时注册捕获和冒泡事件时，事件的触发顺序是按你注册事件的顺序来执行的。

阻止事件冒泡： stopPropagation()和stopImmediaPropagation()方法都能阻止事件的向上冒泡。

但这两者是有区别的：stopImmediaPropagation()还能阻止目标执行别的注册事件。

[https://wangtunan.github.io/blog/interview/#事件机制](https://wangtunan.github.io/blog/interview/#事件机制)

## JSON.stringify

循环引用时会有报错，另外注意下手写深拷贝
