## Vue 的细节

[https://mp.weixin.qq.com/s/gdJWm5Jj1_YhpMUjlfcBVg](https://mp.weixin.qq.com/s/gdJWm5Jj1_YhpMUjlfcBVg)

Vue.js 的响应式系统依赖三个重要的概念，Observer、Dep、Watcher

- 发布者-Observer

  Observe 扮演的角色是发布者，他的主要作用是在组件 vm 初始化的时，调用 defineReactive 函数，使用 Object.defineProperty 方法对对象的每一个子属性进行数据劫持/监听。

  即为每个属性添加 getter 和 setter，将对应的属性值变成响应式。

- 调度中心/订阅器-Dep

  Dep 扮演的角色是调度中心/订阅器，在调用 defineReactive 将属性值变成响应式的过程中，也为每个属性值实例化了一个 Dep，主要作用是对观察者（Watcher）进行管理，收集观察者和通知观察者目标更新。

  即当属性值数据发生改变时，会遍历观察者列表（dep.subs），通知所有的 watcher，让订阅者执行自己的 update 逻辑。

- 观察者-Watcher

  Watcher 扮演的角色是订阅者/观察者，他的主要作用是为观察属性提供回调函数以及收集依赖，当被观察的值发生变化时，会接收到来自调度中心 Dep 的通知，从而触发回调函数。

  而 Watcher 又分为三类，normal-watcher、 computed-watcher、 render-watcher。

  这三种 Watcher 也有固定的执行顺序，分别是：computed-render -> normal-watcher -> render-watcher。这样就能尽可能的保证，在更新组件视图的时候，computed
  属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据。

### 如果不同 route 使用同一个组件

切换路由时并不会触发 beforeDestory 或者重新触发 created 等

## Git 协作

### Git 分支命名

- master：主分支，负责记录上线版本的迭代，该分支代码与线上代码是完全一致的。

- develop：开发分支，该分支记录相对稳定的版本，所有的 feature 分支和 bugfix 分支都从该分支创建。其它分支为短期分支，其完成功能开发之后需要删除

- feature/\*：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 develop 分支，之后删除该分支。

- bugfix/\*：bug 修复分支，用于修复不紧急的 bug，普通 bug 均需要创建 bugfix 分支开发，开发完成自测没问题后合并到 develop 分支后，删除该分支。

- release/\*：发布分支，用于代码上线准备，该分支从 develop 分支创建，创建之后由测试同学发布到测试环境进行测试; 测试过程中发现 bug 需要开发人员在该 release 分支上进行 bug 修复，所有 bug
  修复完后，在上线之前，需要合并该 release 分支到 master 分支和 develop 分支。

- hotfix/\*：紧急 bug 修复分支，该分支只有在紧急情况下使用，从 master 分支创建，用于紧急修复线上 bug，修复完成后，需要合并该分支到 master 分支以便上线，同时需要再合并到 develop 分支。

## 以下题目来源

[https://juejin.cn/post/6866082181455249422](https://juejin.cn/post/6866082181455249422)

这篇文章挺多实际问题，值得看。

## 算法题 数组中第 K 大元素 （快排

## ES6 Proxy 可以拦截的操作

get、set、has、deleteProperty、ownKeys......、apply、construct（拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)）

## 浏览器获取粘贴事件、文件拖入事件

### 粘贴

粘贴事件提供了一个clipboardData的属性，如果该属性有items属性，那么就可以查看items中是否有图片类型的数据了。Chrome有该属性，Safari没有。

```javascript
pasteEle.addEventListener("paste", function (e) {
  if (!(e.clipboardData && e.clipboardData.items)) {
    return;
  }
});
```

items的DataTransferItem有两个属性kind（一般为string或者file）和type（MIME-Type），有方法：getAsFile（kind 是文件时）、getAsString

type 常见：text/plain、text/html、Files

getAsString 方法是传入一个回调函数接收文字内容

### 文件拖入

dragenter(文件拖拽进)、dragover(文件拖拽在悬浮)、dragleave(文件拖拽离开)、drop(文件拖拽放下)。

还需要阻止默认行为（例如拖入 pdf 页面就跳走到预览了）

```javascript
dropZone.addEventListener("drop", function (e) {
  e.preventDefault();
  e.stopPropagation();

  var df = e.dataTransfer;
  var dropFiles = []; // 存放拖拽的文件对象

  if (df.items !== undefined) {
    // Chrome有items属性，对Chrome的单独处理
    for (var i = 0; i < df.items.length; i++) {
      var item = df.items[i];
      // 用webkitGetAsEntry禁止上传目录
      if (item.kind === "file" && item.webkitGetAsEntry().isFile) {
        var file = item.getAsFile();
        dropFiles.push(file);
      }
    }
  }
}
```

## js 怎样实现压缩图片

[https://segmentfault.com/a/1190000023486410](https://segmentfault.com/a/1190000023486410)

## koa 与 express 对比

- express内置了许多中间件可供使用，而koa没有。

- express包含路由，视图渲染等特性，而koa只有http模块。

- express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。

- express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。

总结：

Express

+ 优点：线性逻辑，通过中间件形式把业务逻辑细分、简化，一个请求进来经过一系列中间件处理后再响应给用户，清晰明了。
+ 缺点：基于 callback 组合业务逻辑，业务逻辑复杂时嵌套过多，异常捕获困难。

Koa

+ 优点：首先，借助 co 和 generator，很好地解决了异步流程控制和异常捕获问题。其次，Koa 把 Express 中内置的 router、view 等功能都移除了，使得框架本身更轻量。
+ 缺点：社区相对较小。

## unicode 与中文转换

```javascript
escape("你好").replace(/\%u/g, '/u'); // "/u4F60/u597D"
eval("'" + "\u4F60\u597D" + "'");   // 你好
unescape("\u4F60\u597D");   // 你好
```
